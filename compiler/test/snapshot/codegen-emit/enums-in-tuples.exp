Enums in tuples

SOURCE:
enum Foo { Bar, Baz }

fn borgo_main() {
    let res = match (Bar, Baz) {
        (Bar, Bar) => 0,
        (Bar, Baz) => 2,
        _ => unreachable!(),
    };

    res.assert_eq(2);
}

OUTPUT:

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit
var make_Foo_Bar = Foo_Bar{}
var make_Foo_Baz = Foo_Baz{}

type Foo_Bar struct {
}
type Foo_Baz struct {
}
type Foo any

func borgo_main() any {

	var var1_block any
	{
		var2 := make_Foo_Bar
		var3 := make_Foo_Baz
		var4 := func(base any) any {
			data := base.(Tuple2)
			data.First = var2
			data.Second = var3
			return data
		}(Tuple2{})
		var var5_result any
		var6_subject := var4
		var7_matches := 0

		if var7_matches != 2 {
			var7_matches = 0

			var8_match_pat := 0
			var10_match_pat := 0

			var9_pat, constructor_check := var6_subject.(Tuple2).First.(Foo_Bar)
			_ = var9_pat

			if var10_match_pat != 1 && constructor_check {
				var8_match_pat = 2
			} else {
				var8_match_pat = 1
			}

			var12_match_pat := 0

			var11_pat, constructor_check := var6_subject.(Tuple2).Second.(Foo_Bar)
			_ = var11_pat

			if var12_match_pat != 1 && constructor_check {
				var8_match_pat = 2
			} else {
				var8_match_pat = 1
			}

			if var8_match_pat != 1 {
				var7_matches = 2
			} else {
				var7_matches = 1
			}

			_ = var6_subject

			if var7_matches == 2 {
				var13 := 0
				var5_result = var13
			}
		}

		if var7_matches != 2 {
			var7_matches = 0

			var14_match_pat := 0
			var16_match_pat := 0

			var15_pat, constructor_check := var6_subject.(Tuple2).First.(Foo_Bar)
			_ = var15_pat

			if var16_match_pat != 1 && constructor_check {
				var14_match_pat = 2
			} else {
				var14_match_pat = 1
			}

			var18_match_pat := 0

			var17_pat, constructor_check := var6_subject.(Tuple2).Second.(Foo_Baz)
			_ = var17_pat

			if var18_match_pat != 1 && constructor_check {
				var14_match_pat = 2
			} else {
				var14_match_pat = 1
			}

			if var14_match_pat != 1 {
				var7_matches = 2
			} else {
				var7_matches = 1
			}

			_ = var6_subject

			if var7_matches == 2 {
				var19 := 2
				var5_result = var19
			}
		}

		if var7_matches != 2 {
			var7_matches = 0

			if var7_matches != 1 {
				var7_matches = 2 /* wildcard */
			}
			_ = var6_subject

			if var7_matches == 2 {
				var20 := Debug_unreachable()
				var5_result = var20
			}
		}

		var21 := var5_result
		var22 := borgo.Unit
		_ = var22
		var23 := var21
		var24 := 2
		var25 := Debug_assert_eq
		var26 := var25(var23, var24)
		var1_block = var26
	}
	return var1_block
}

func Foo_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Foo_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Foo_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func pkg_user_init() {
	borgo.RegisterTypeConstructor("Foo::Bar", "Foo_Bar")
	borgo.RegisterMakeFunction("Foo::Bar", make_Foo_Bar)
	borgo.RegisterTypeConstructor("Foo::Baz", "Foo_Baz")
	borgo.RegisterMakeFunction("Foo::Baz", make_Foo_Baz)
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
