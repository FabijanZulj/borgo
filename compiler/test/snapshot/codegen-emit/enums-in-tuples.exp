Enums in tuples

SOURCE:
enum Foo { Bar, Baz }

fn borgo_main() {
    let res = match (Bar, Baz) {
        (Bar, Bar) => 0,
        (Bar, Baz) => 2,
        _ => unreachable!(),
    };

    res.assert_eq(2);
}

OUTPUT:

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit
var make_Foo_Bar = Foo_Bar{}
var make_Foo_Baz = Foo_Baz{}

type Foo_Bar struct {
}
type Foo_Baz struct {
}
type Foo any

func borgo_main() any {

	{
		var var1 any
		_ = var1

		var5_subject := func(base any) any {
			data := base.(Tuple2)
			data.First = make_Foo_Bar
			data.Second = make_Foo_Baz
			return data
		}(Tuple2{})
		var6_matches := borgo.MatchNone

		if var6_matches != borgo.MatchOk {
			var6_matches = borgo.MatchNone

			var7_match_pat := borgo.MatchNone
			var9_match_pat := borgo.MatchNone

			var8_pat, constructor_check := var5_subject.(Tuple2).First.(Foo_Bar)
			_ = var8_pat

			if var9_match_pat != borgo.MatchErr && constructor_check {
				var7_match_pat = borgo.MatchOk
			} else {
				var7_match_pat = borgo.MatchErr
			}

			var11_match_pat := borgo.MatchNone

			var10_pat, constructor_check := var5_subject.(Tuple2).Second.(Foo_Bar)
			_ = var10_pat

			if var11_match_pat != borgo.MatchErr && constructor_check {
				var7_match_pat = borgo.MatchOk
			} else {
				var7_match_pat = borgo.MatchErr
			}

			if var7_match_pat != borgo.MatchErr {
				var6_matches = borgo.MatchOk
			} else {
				var6_matches = borgo.MatchErr
			}

			_ = var5_subject

			if var6_matches == borgo.MatchOk {

				var1 = 0
			}
		}

		if var6_matches != borgo.MatchOk {
			var6_matches = borgo.MatchNone

			var12_match_pat := borgo.MatchNone
			var14_match_pat := borgo.MatchNone

			var13_pat, constructor_check := var5_subject.(Tuple2).First.(Foo_Bar)
			_ = var13_pat

			if var14_match_pat != borgo.MatchErr && constructor_check {
				var12_match_pat = borgo.MatchOk
			} else {
				var12_match_pat = borgo.MatchErr
			}

			var16_match_pat := borgo.MatchNone

			var15_pat, constructor_check := var5_subject.(Tuple2).Second.(Foo_Baz)
			_ = var15_pat

			if var16_match_pat != borgo.MatchErr && constructor_check {
				var12_match_pat = borgo.MatchOk
			} else {
				var12_match_pat = borgo.MatchErr
			}

			if var12_match_pat != borgo.MatchErr {
				var6_matches = borgo.MatchOk
			} else {
				var6_matches = borgo.MatchErr
			}

			_ = var5_subject

			if var6_matches == borgo.MatchOk {

				var1 = 2
			}
		}

		if var6_matches != borgo.MatchOk {
			var6_matches = borgo.MatchNone

			if var6_matches != borgo.MatchErr {
				var6_matches = borgo.MatchOk /* wildcard */
			}
			_ = var5_subject

			if var6_matches == borgo.MatchOk {

				var1 = Debug_unreachable()
			}
		}

		var res any = var1

		return Debug_assert_eq(res, 2)
	}
}
func Foo_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Foo_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Foo_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func pkg_user_init() {
	borgo.RegisterTypeConstructor("Foo::Bar", "Foo_Bar")
	borgo.RegisterMakeFunction("Foo::Bar", make_Foo_Bar)
	borgo.RegisterTypeConstructor("Foo::Baz", "Foo_Baz")
	borgo.RegisterMakeFunction("Foo::Baz", make_Foo_Baz)
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
