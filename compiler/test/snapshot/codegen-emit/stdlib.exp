Stdlib

SOURCE:
fn borgo_main() {
  let x = [1,2,3];

  x.push(4).assert_eq([1,2,3,4]);
  x.pop().assert_eq([1,2]);
  x.pop().pop().pop().pop().is_empty().assert_eq(true);

  //
  // Sequence
  //
  let s = Seq::infinite(0, |n| n + 3);

  s.take(3).len().assert_eq(3);

  s
    .take(50)
    .to_list()
    .get(4)
    .assert_eq(Some(12));

  x
    .seq()
    .filter(|n| n > 1)
    .map(|n| n * 8)
    .to_list()
    .get(1)
    .inspect();

  s
    .take(10)
    .sum()
    .assert_eq(135);

  s
    .drop(10)
    .take(1)
    .to_list()
    .get(0)
    .assert_eq(Some(30));

  {
    let (first, last) = s.split_at(5);
    first.sum().assert_eq(30);
    last.take(5).to_list().assert_eq([15, 18, 21, 24, 27]);
  }

  {
    let foo = s.chunks(2);
    foo.get(0).unwrap().sum().assert_eq(3);
    foo.get(1).unwrap().sum().assert_eq(15);
    foo.get(2).unwrap().sum().assert_eq(27);

    let bar = s.take(5).chunks(3);
    bar.get(0).unwrap().sum().assert_eq(9);
    bar.get(1).unwrap().sum().assert_eq(21);
    bar.get(2).assert_eq(None);
  }

  {
    let foo = s.windows(2);
    foo.get(0).unwrap().sum().assert_eq(3);
    foo.get(1).unwrap().sum().assert_eq(9);
    foo.get(2).unwrap().sum().assert_eq(15);

    let bar = s.take(5).windows(3);
    bar.get(0).unwrap().sum().assert_eq(9);
    bar.get(1).unwrap().sum().assert_eq(18);
    bar.get(2).is_some().assert_eq(true);
    bar.get(3).is_none().assert_eq(true);
  }

  s
    .find_map(|x| if x == 21 { Some(x) } else { None })
    .assert_eq(Some(21));

  s
    .take(10)
    .max_by(Int::cmp)
    .assert_eq(Some(27));


  {
    let other = ["a", "b", "c"];
    let zipped = s.zip(other.seq());
    zipped.get(1).assert_eq(Some((3, "b")));
    zipped.get(3).assert_eq(None);
  }

  ["a", "b", "c"]
    .seq()
    .enumerate()
    .get(2).unwrap().assert_eq((2, "c"));

  {
    let chained = s.drop(100).take(5)
      .chain(s)
      .take(10)
      .to_list();

    chained
      .get(4)
      .assert_eq(Some(312));

    chained
      .get(6) // one after the initial sequence
      .assert_eq(Some(3));
  }

  //
  // Map
  //
  let m = Map::new()
    .insert("foo", 6)
    .insert("bar", 8);

  m.len().assert_eq(2);
  m.get("bar").assert_eq(Some(8));
  m.get("xyz").assert_eq(None);

  m
    .seq()
    .to_list()
    .get(0)
    .assert_eq(Some(("foo", 6)));

  m
    .seq_keys()
    .to_list()
    .get(1)
    .assert_eq(Some("bar"));

  Map::new()
    .insert(99, "baz")
    .get(99)
    .assert_eq(Some("baz"));

  [("a", 1), ("b", 2)]
  .seq()
  .to_map()
  .len()
  .assert_eq(2);

  //
  // Set
  //
  let set = Set::new()
    .insert(1)
    .insert(2);

  set.contains(1).assert_eq(true);
  set.contains(3).assert_eq(false);

  set.delete(2).assert_eq(Set::new().insert(1));

  [1,2,3].seq().to_set().assert_eq(
    Set::new()
        .insert(1)
        .insert(2)
        .insert(3)
  );


  //
  // Option
  //
  Option::None.unwrap_or_else(|| 4).assert_eq(4);
}

OUTPUT:
Option::Some(24)

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func borgo_main() any {

	{

		var x any = borgo.List(1, 2, 3)

		Debug_assert_eq(List_push(x, 4), borgo.List(1, 2, 3, 4))

		Debug_assert_eq(List_pop(x), borgo.List(1, 2))

		Debug_assert_eq(List_is_empty(List_pop(List_pop(List_pop(List_pop(x))))), true)

		var s any = Seq_infinite(0, func(n any) any {

			{

				return borgo.Ops.IAdd(n, 3)
			}
		})

		Debug_assert_eq(Seq_len(Seq_take(s, 3)), 3)

		Debug_assert_eq(List_get(Seq_to_list(Seq_take(s, 50)), 4), make_Option_Some(12))

		Debug_inspect(List_get(Seq_to_list(Seq_map(Seq_filter(List_seq(x), func(n any) any {

			{

				return borgo.Ops.IGt(n, 1)
			}
		}), func(n any) any {

			{

				return borgo.Ops.IMul(n, 8)
			}
		})), 1))

		Debug_assert_eq(Seq_sum(Seq_take(s, 10)), 135)

		Debug_assert_eq(List_get(Seq_to_list(Seq_take(Seq_drop(s, 10), 1)), 0), make_Option_Some(30))
		{

			var114 := Seq_split_at(s, 5)
			var115_match_pat := borgo.MatchNone
			first := var114.(Tuple2).First
			last := var114.(Tuple2).Second

			if var115_match_pat != borgo.MatchErr {
				_ = borgo.MatchOk
			} else {
				_ = borgo.MatchErr
			}

			Debug_assert_eq(Seq_sum(first), 30)

			Debug_assert_eq(Seq_to_list(Seq_take(last, 5)), borgo.List(15, 18, 21, 24, 27))
		}
		{

			var foo any = Seq_chunks(s, 2)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(foo, 0))), 3)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(foo, 1))), 15)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(foo, 2))), 27)

			var bar any = Seq_chunks(Seq_take(s, 5), 3)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(bar, 0))), 9)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(bar, 1))), 21)

			Debug_assert_eq(Seq_get(bar, 2), make_Option_None)
		}
		{

			var foo any = Seq_windows(s, 2)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(foo, 0))), 3)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(foo, 1))), 9)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(foo, 2))), 15)

			var bar any = Seq_windows(Seq_take(s, 5), 3)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(bar, 0))), 9)

			Debug_assert_eq(Seq_sum(Option_unwrap(Seq_get(bar, 1))), 18)

			Debug_assert_eq(Option_is_some(Seq_get(bar, 2)), true)

			Debug_assert_eq(Option_is_none(Seq_get(bar, 3)), true)
		}

		Debug_assert_eq(Seq_find_map(s, func(x any) any {

			{
				var var281 any
				_ = var281

				if borgo.Ops.Eq(borgo.Ops.Eq(x, 21), true).(bool) {

					var281 = make_Option_Some(x)
				} else {

					var281 = make_Option_None
				}
				return var281
			}
		}), make_Option_Some(21))

		Debug_assert_eq(Seq_max_by(Seq_take(s, 10), Int_cmp), make_Option_Some(27))
		{

			var other any = borgo.List("a", "b", "c")

			var zipped any = Seq_zip(s, List_seq(other))

			Debug_assert_eq(Seq_get(zipped, 1), make_Option_Some(func(base any) any {
				data := base.(Tuple2)
				data.First = 3
				data.Second = "b"
				return data
			}(Tuple2{})))

			Debug_assert_eq(Seq_get(zipped, 3), make_Option_None)
		}

		Debug_assert_eq(Option_unwrap(Seq_get(Seq_enumerate(List_seq(borgo.List("a", "b", "c"))), 2)), func(base any) any {
			data := base.(Tuple2)
			data.First = 2
			data.Second = "c"
			return data
		}(Tuple2{}))
		{

			var chained any = Seq_to_list(Seq_take(Seq_chain(Seq_take(Seq_drop(s, 100), 5), s), 10))

			Debug_assert_eq(List_get(chained, 4), make_Option_Some(312))

			Debug_assert_eq(List_get(chained, 6), make_Option_Some(3))
		}

		var m any = Map_insert(Map_insert(Map_new(), "foo", 6), "bar", 8)

		Debug_assert_eq(Map_len(m), 2)

		Debug_assert_eq(Map_get(m, "bar"), make_Option_Some(8))

		Debug_assert_eq(Map_get(m, "xyz"), make_Option_None)

		Debug_assert_eq(List_get(Seq_to_list(Map_seq(m)), 0), make_Option_Some(func(base any) any {
			data := base.(Tuple2)
			data.First = "foo"
			data.Second = 6
			return data
		}(Tuple2{})))

		Debug_assert_eq(List_get(Seq_to_list(Map_seq_keys(m)), 1), make_Option_Some("bar"))

		Debug_assert_eq(Map_get(Map_insert(Map_new(), 99, "baz"), 99), make_Option_Some("baz"))

		Debug_assert_eq(Map_len(to_map(List_seq(borgo.List(func(base any) any {
			data := base.(Tuple2)
			data.First = "a"
			data.Second = 1
			return data
		}(Tuple2{}), func(base any) any {
			data := base.(Tuple2)
			data.First = "b"
			data.Second = 2
			return data
		}(Tuple2{}))))), 2)

		var set any = Set_insert(Set_insert(Set_new(), 1), 2)

		Debug_assert_eq(Set_contains(set, 1), true)

		Debug_assert_eq(Set_contains(set, 3), false)

		Debug_assert_eq(Set_delete(set, 2), Set_insert(Set_new(), 1))

		Debug_assert_eq(to_set(List_seq(borgo.List(1, 2, 3))), Set_insert(Set_insert(Set_insert(Set_new(), 1), 2), 3))

		return Debug_assert_eq(Option_unwrap_or_else(make_Option_None, func() any {

			{

				return 4
			}
		}), 4)
	}
}

func pkg_user_init() {
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
