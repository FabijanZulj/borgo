Multiple files

SOURCE:
file: foo.brg
enum Foo {
  X(Bar),
}

file: bar.brg
enum Bar {
  A(Int),
}

fn with_foo(f: Foo, m: Int) -> Int {
  match f {
    Foo::X(b) => match b {
      Bar::A(n) => n + m
    }
  }
}

file: main.brg
fn borgo_main() {
  let bar = Bar::A(2);
  with_foo(Foo::X(bar), 3).assert_eq(5);
}

OUTPUT:

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func make_Bar_A(arg_0 any) any {
	return Bar_A{arg_0}
}

func make_Foo_X(arg_0 any) any {
	return Foo_X{arg_0}
}
func borgo_main() any {

	{

		var bar any = make_Bar_A(2)

		return Debug_assert_eq(with_foo(make_Foo_X(bar), 3), 5)
	}
}

type Bar_A struct {
	Field0 any
}
type Bar any

func with_foo(f any, m any) any {

	{
		var var1 any
		_ = var1

		var3_subject := f
		var4_matches := borgo.MatchNone

		if var4_matches != borgo.MatchOk {
			var4_matches = borgo.MatchNone

			var6_match_pat := borgo.MatchNone

			var5_pat, constructor_check := var3_subject.(Foo_X)
			_ = var5_pat

			b := var5_pat.Field0

			if var6_match_pat != borgo.MatchErr && constructor_check {
				var4_matches = borgo.MatchOk
			} else {
				var4_matches = borgo.MatchErr
			}

			_ = var3_subject

			if var4_matches == borgo.MatchOk {

				var8_subject := b
				var9_matches := borgo.MatchNone

				if var9_matches != borgo.MatchOk {
					var9_matches = borgo.MatchNone

					var11_match_pat := borgo.MatchNone

					var10_pat, constructor_check := var8_subject.(Bar_A)
					_ = var10_pat

					n := var10_pat.Field0

					if var11_match_pat != borgo.MatchErr && constructor_check {
						var9_matches = borgo.MatchOk
					} else {
						var9_matches = borgo.MatchErr
					}

					_ = var8_subject

					if var9_matches == borgo.MatchOk {

						var1 = borgo.Ops.IAdd(n, m)
					}
				}

			}
		}

		return var1
	}
}

type Foo_X struct {
	Field0 any
}
type Foo any

func Bar_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Foo_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Bar_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Foo_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Bar_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func Foo_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func pkg_user_init() {
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
	borgo.RegisterTypeConstructor("Bar::A", "Bar_A")
	borgo.RegisterMakeFunction("Bar::A", make_Bar_A)
	borgo.RegisterGlobalFunction("with_foo", with_foo)
	borgo.RegisterTypeConstructor("Foo::X", "Foo_X")
	borgo.RegisterMakeFunction("Foo::X", make_Foo_X)
}
