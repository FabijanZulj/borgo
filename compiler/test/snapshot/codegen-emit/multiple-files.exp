Multiple files

SOURCE:
file: foo.brg
enum Foo {
  X(Bar),
}

file: bar.brg
enum Bar {
  A(Int),
}

fn with_foo(f: Foo, m: Int) -> Int {
  match f {
    Foo::X(b) => match b {
      Bar::A(n) => n + m
    }
  }
}

file: main.brg
fn borgo_main() {
  let bar = Bar::A(2);
  with_foo(Foo::X(bar), 3).assert_eq(5);
}

OUTPUT:

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func make_Bar_A(arg_0 any) any {
	return Bar_A{arg_0}
}

func make_Foo_X(arg_0 any) any {
	return Foo_X{arg_0}
}
func borgo_main() any {

	var var1_block any
	{
		var2 := 2
		var3 := make_Bar_A
		var4 := var3(var2)
		var5 := var4
		var6 := borgo.Unit
		_ = var6
		var7 := var5
		var8 := make_Foo_X
		var9 := var8(var7)
		var10 := 3
		var11 := with_foo
		var12 := var11(var9, var10)
		var13 := 5
		var14 := Debug_assert_eq
		var15 := var14(var12, var13)
		var1_block = var15
	}
	return var1_block
}

type Bar_A struct {
	Field0 any
}
type Bar any

func with_foo(f any, m any) any {

	var var1_block any
	{
		var2 := f
		var var3_result any
		var4_subject := var2
		var5_matches := 0

		if var5_matches != 2 {
			var5_matches = 0

			var7_match_pat := 0

			var6_pat, constructor_check := var4_subject.(Foo_X)
			_ = var6_pat

			var8 := var6_pat.Field0

			if var7_match_pat != 1 && constructor_check {
				var5_matches = 2
			} else {
				var5_matches = 1
			}

			_ = var4_subject

			if var5_matches == 2 {
				var9 := var8
				var var10_result any
				var11_subject := var9
				var12_matches := 0

				if var12_matches != 2 {
					var12_matches = 0

					var14_match_pat := 0

					var13_pat, constructor_check := var11_subject.(Bar_A)
					_ = var13_pat

					var15 := var13_pat.Field0

					if var14_match_pat != 1 && constructor_check {
						var12_matches = 2
					} else {
						var12_matches = 1
					}

					_ = var11_subject

					if var12_matches == 2 {
						var16 := var15
						var17 := m
						var18 := borgo.Ops.IAdd
						var19 := var18(var16, var17)
						var10_result = var19
					}
				}

				var3_result = var10_result
			}
		}

		var1_block = var3_result
	}
	return var1_block
}

type Foo_X struct {
	Field0 any
}
type Foo any

func Bar_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Foo_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Bar_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Foo_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Bar_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func Foo_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func pkg_user_init() {
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
	borgo.RegisterTypeConstructor("Bar::A", "Bar_A")
	borgo.RegisterMakeFunction("Bar::A", make_Bar_A)
	borgo.RegisterGlobalFunction("with_foo", with_foo)
	borgo.RegisterTypeConstructor("Foo::X", "Foo_X")
	borgo.RegisterMakeFunction("Foo::X", make_Foo_X)
}
