Multiple files

SOURCE:
file: foo.brg
enum Foo {
  X(Bar),
}

file: bar.brg
enum Bar {
  A(int),
}

fn with_foo(f: Foo, m: int) -> int {
  match f {
    Foo::X(b) => match b {
      Bar::A(n) => n + m
    }
  }
}

file: main.brg
fn main() {
  let bar = Bar::A(2);
  assert_eq(with_foo(Foo::X(bar), 3), 5);
}

OUTPUT:

---
package main

func make_Bar_A(arg_0 int) Bar {
	return Bar{tag: Bar_A, A: arg_0}
}

func make_Foo_X(arg_0 Bar) Foo {
	return Foo{tag: Foo_X, X: arg_0}
}

type BarTag int

const (
	Bar_A BarTag = iota
)

type Bar struct {
	tag BarTag
	A   int
}

func with_foo(f Foo, m int) int {
	var var3 int
	var1_subject := f
	var2_matches := 0

	if var2_matches != 2 {
		var2_matches = 0

		var4_match_pat := 0
		b := var1_subject.X

		if var4_match_pat != 1 && var1_subject.tag == Foo_X {
			var2_matches = 2
		} else {
			var2_matches = 1
		}

		_ = var1_subject

		if var2_matches == 2 {

			var6_subject := b
			var7_matches := 0

			if var7_matches != 2 {
				var7_matches = 0

				var8_match_pat := 0
				n := var6_subject.A

				if var8_match_pat != 1 && var6_subject.tag == Bar_A {
					var7_matches = 2
				} else {
					var7_matches = 1
				}

				_ = var6_subject

				if var7_matches == 2 {
					var3 = n + m
				}
			}

		}
	}

	return var3
}

type FooTag int

const (
	Foo_X FooTag = iota
)

type Foo struct {
	tag FooTag
	X   Bar
}

func main() {
	bar := make_Bar_A(2)

	assert_eq[int](with_foo(make_Foo_X(bar), 3), 5)
}
