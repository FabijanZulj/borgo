Recursive types

SOURCE:
enum Expr {
  Add(Expr, Expr),
  Number(Int),
}

struct Foo {
  n: String,
  f: Option<Foo>,
}

fn borgo_main() {
  let one = Expr::Number(1);
  let two = Expr::Number(2);
  let e = Expr::Add(one, two);
  e.inspect();

  let f = Foo { n: "a", f: None };
  let ok = Foo { n: "b", f: Some(f) };
  ok.inspect();
  ()
}

OUTPUT:
Expr::Add(Expr::Number(1), Expr::Number(2))
Foo { n: "b", f: Option::Some(Foo { n: "a", f: Option::None }) }

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func make_Expr_Add(arg_0 any, arg_1 any) any {
	return Expr_Add{arg_0, arg_1}
}

func make_Expr_Number(arg_0 any) any {
	return Expr_Number{arg_0}
}
func make_Foo(arg_0 any, arg_1 any) any {
	return Foo{arg_0, arg_1}
}

type Expr_Add struct {
	Field0 any
	Field1 any
}
type Expr_Number struct {
	Field0 any
}
type Expr any
type Foo struct {
	N any
	F any
}

func borgo_main() any {

	{

		var one any = make_Expr_Number(1)

		var two any = make_Expr_Number(2)

		var e any = make_Expr_Add(one, two)
		Debug_inspect(e)

		var f any = func(base any) any {
			data := base.(Foo)
			data.N = "a"
			data.F = make_Option_None
			return data
		}(Foo{})

		var ok any = func(base any) any {
			data := base.(Foo)
			data.N = "b"
			data.F = make_Option_Some(f)
			return data
		}(Foo{})
		Debug_inspect(ok)

		return borgo.Unit
	}
}
func Expr_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Foo_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Expr_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Foo_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Expr_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func Foo_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func pkg_user_init() {
	borgo.RegisterTypeConstructor("Expr::Add", "Expr_Add")
	borgo.RegisterMakeFunction("Expr::Add", make_Expr_Add)
	borgo.RegisterTypeConstructor("Expr::Number", "Expr_Number")
	borgo.RegisterMakeFunction("Expr::Number", make_Expr_Number)
	borgo.RegisterStruct("Foo", "Foo", []string{"n", "f"})
	borgo.RegisterMakeFunction("Foo", make_Foo)
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
