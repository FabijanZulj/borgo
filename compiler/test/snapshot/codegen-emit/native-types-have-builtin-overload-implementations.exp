Native types have builtin overload implementations.

SOURCE:
fn borgo_main() {
  1.to_string().inspect();
  1.to_hash().inspect();
  1.equals(1).inspect();

  "hello".to_string().inspect();
  "hello".to_hash().inspect();
  "hello".equals("hello").inspect();

  (1.34).to_string().inspect();
  (1.34).to_hash().inspect();
  (1.34).equals(1.34).inspect();

  'f'.to_string().inspect();
  'f'.to_hash().inspect();
  'f'.equals('f').inspect();

  false.to_string().inspect();
  false.to_hash().inspect();
  false.equals(false).inspect();

  [1, 2, 3].to_string().inspect();
  [1, 2, 3].to_hash().inspect();
  [1, 2, 3].equals([1, 2, 3]).inspect();

  ().to_string().inspect();
  ().to_hash().inspect();
  ().equals(()).inspect();

  ()
}

OUTPUT:
"1"
1
true
""hello""
1335831723
true
"1.34"
823105137
true
"'f'"
102
true
"false"
0
true
"[1, 2, 3]"
3507393745
true
"()"
685372826
true

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func borgo_main() any {

	{

		Debug_inspect(Int_to_string(1))

		Debug_inspect(Int_to_hash(1))

		Debug_inspect(Int_equals(1, 1))

		Debug_inspect(String_to_string("hello"))

		Debug_inspect(String_to_hash("hello"))

		Debug_inspect(String_equals("hello", "hello"))

		Debug_inspect(Float_to_string((1.34)))

		Debug_inspect(Float_to_hash((1.34)))

		Debug_inspect(Float_equals((1.34), 1.34))

		Debug_inspect(Char_to_string('f'))

		Debug_inspect(Char_to_hash('f'))

		Debug_inspect(Char_equals('f', 'f'))

		Debug_inspect(Bool_to_string(false))

		Debug_inspect(Bool_to_hash(false))

		Debug_inspect(Bool_equals(false, false))

		Debug_inspect(List_to_string(borgo.List(1, 2, 3)))

		Debug_inspect(List_to_hash(borgo.List(1, 2, 3)))

		Debug_inspect(List_equals(borgo.List(1, 2, 3), borgo.List(1, 2, 3)))

		Debug_inspect(Unit_to_string(borgo.Unit))

		Debug_inspect(Unit_to_hash(borgo.Unit))

		Debug_inspect(Unit_equals(borgo.Unit, borgo.Unit))

		return borgo.Unit
	}
}

func pkg_user_init() {
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
