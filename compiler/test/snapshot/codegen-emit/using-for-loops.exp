Using for loops.

SOURCE:
fn borgo_main() {
  for x in [1, 2, 3].seq() {
    x.inspect();
  }

  let mut n = 20;

  match true {
    true => { n = 25; },
    false => (),
  }

  loop {
    if n > 27 { break; }
    n.inspect();
    n = n + 1;
  }
}

OUTPUT:
1
2
3
25
26
27

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func borgo_main() any {

	{

		var1 := List_seq(borgo.List(1, 2, 3))
		for !borgo.ValuesIsOfType(var1, "Seq::Nil") {
			var8 := var1.(Seq_Cons).Field0

			var x any = var8
			Debug_inspect(x)

			var1 = var1.(Seq_Cons).Field1()
		}

		var n any = 20

		var13_subject := true
		var14_matches := borgo.MatchNone

		if var14_matches != borgo.MatchOk {
			var14_matches = borgo.MatchNone

			if var14_matches != borgo.MatchErr && borgo.Ops.Eq(true, var13_subject).(bool) {
				var14_matches = borgo.MatchOk
			} else {
				var14_matches = borgo.MatchErr
			}
			_ = var13_subject

			if var14_matches == borgo.MatchOk {

				n = 25

			}
		}

		if var14_matches != borgo.MatchOk {
			var14_matches = borgo.MatchNone

			if var14_matches != borgo.MatchErr && borgo.Ops.Eq(false, var13_subject).(bool) {
				var14_matches = borgo.MatchOk
			} else {
				var14_matches = borgo.MatchErr
			}
			_ = var13_subject

			if var14_matches == borgo.MatchOk {

			}
		}

		for {
			{

				if borgo.Ops.Eq(borgo.Ops.IGt(n, 27), true).(bool) {
					break

				}
				Debug_inspect(n)

				n = borgo.Ops.IAdd(n, 1)
			}
		}
		return borgo.Unit
	}
}

func pkg_user_init() {
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
