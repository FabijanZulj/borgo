Custom overload implementations.

SOURCE:
struct Foo<T> { x: Int, y: Bar<T> }

struct Bar<T> {
  a: String,
  b: T,
}

struct Baz<T> { one: Int, two: T }

impl<T> Baz<T> {
  fn to_string<T: to_string>(self) -> String {
    "BAZ [ \n ONE: "
      .append(self.one.to_string())
      .append(", TWO: ")
      .append(to_string(self.two))
      .append("\n ]")
  }
}

struct Bad { bad: Bool }

fn borgo_main() {
  let bar: Bar<Baz<Bad>> = Bar {
    a: "yo",
    b: Baz {
      one: 1,
      two: Bad { bad: false },
    }
  };

  bar.inspect();
  ()
}

OUTPUT:
Bar { a: "yo", b: BAZ [ 
 ONE: 1, TWO: Bad { bad: false }
 ] }

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func make_Foo(arg_0 any, arg_1 any) any {
	return Foo{arg_0, arg_1}
}
func make_Bar(arg_0 any, arg_1 any) any {
	return Bar{arg_0, arg_1}
}
func make_Baz(arg_0 any, arg_1 any) any {
	return Baz{arg_0, arg_1}
}
func make_Bad(arg_0 any) any {
	return Bad{arg_0}
}

type Foo struct {
	X any
	Y any
}
type Bar struct {
	A any
	B any
}
type Baz struct {
	One any
	Two any
}

func Baz_to_string(self any) any {

	{

		return String_append(String_append(String_append(String_append("BAZ [ \n ONE: ", Int_to_string(self.(Baz).One)), ", TWO: "), to_string(self.(Baz).Two)), "\n ]")
	}
}

type Bad struct {
	Bad any
}

func borgo_main() any {

	{

		var bar any = func(base any) any {
			data := base.(Bar)
			data.A = "yo"
			data.B = func(base any) any {
				data := base.(Baz)
				data.One = 1
				data.Two = func(base any) any {
					data := base.(Bad)
					data.Bad = false
					return data
				}(Bad{})
				return data
			}(Baz{})
			return data
		}(Bar{})
		Debug_inspect(bar)

		return borgo.Unit
	}
}
func Bad_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Bar_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Baz_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Foo_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Bad_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Bar_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Baz_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Foo_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Bad_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func Bar_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func Foo_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func pkg_user_init() {
	borgo.RegisterStruct("Foo", "Foo", []string{"x", "y"})
	borgo.RegisterMakeFunction("Foo", make_Foo)
	borgo.RegisterStruct("Bar", "Bar", []string{"a", "b"})
	borgo.RegisterMakeFunction("Bar", make_Bar)
	borgo.RegisterStruct("Baz", "Baz", []string{"one", "two"})
	borgo.RegisterMakeFunction("Baz", make_Baz)
	borgo.RegisterGlobalFunction("Baz::to_string", Baz_to_string)
	borgo.RegisterStruct("Bad", "Bad", []string{"bad"})
	borgo.RegisterMakeFunction("Bad", make_Bad)
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
