Select statement

SOURCE:
fn foo(x: Sender<Int>) {
  x.send(3)
}

fn borgo_main() {
  let (x_send, x_recv) = Channel::new();
  let (_, y_recv) = Channel::new();

  spawn!((|| { x_send.send(5) })());

  let val = x_recv.recv();
  val.unwrap().assert_eq(5);

  spawn!(foo(x_send));

  match select!() {
    ChannelOp::Recv(x_recv, val) => val.unwrap().assert_eq(3),
    ChannelOp::Recv(y_recv, _) => unreachable!(),
  };
}

OUTPUT:

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func foo(x any) any {

	{

		return Sender_send(x, 3)
	}
}
func borgo_main() any {

	{

		var3 := Channel_new()
		var4_match_pat := borgo.MatchNone
		x_send := var3.(Tuple2).First
		x_recv := var3.(Tuple2).Second

		if var4_match_pat != borgo.MatchErr {
			_ = borgo.MatchOk
		} else {
			_ = borgo.MatchErr
		}

		var7 := Channel_new()
		var8_match_pat := borgo.MatchNone
		if var8_match_pat != borgo.MatchErr {
			var8_match_pat = borgo.MatchOk /* wildcard */
		}
		y_recv := var7.(Tuple2).Second

		if var8_match_pat != borgo.MatchErr {
			_ = borgo.MatchOk
		} else {
			_ = borgo.MatchErr
		}

		go (func() any {

			{

				return Sender_send(x_send, 5)
			}
		})()

		var val any = Receiver_recv(x_recv)

		Debug_assert_eq(Option_unwrap(val), 5)
		go foo(x_send)
		select {
		case var26_value, var27_more := <-x_recv.(chan any):
			var val any
			if var27_more {
				val = make_Option_Some(var26_value)
			} else {
				val = make_Option_None
			}

			Debug_assert_eq(Option_unwrap(val), 3)
		case var33_value, var34_more := <-y_recv.(chan any):

			if var34_more {
				_ = make_Option_Some(var33_value)
			} else {
				_ = make_Option_None
			}
			Debug_unreachable()
		}
		return borgo.Unit
	}
}

func pkg_user_init() {
	borgo.RegisterGlobalFunction("foo", foo)
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
