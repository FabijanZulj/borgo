Try operator

SOURCE:
enum Error { Foo(String) }

fn foo(b: Bool) -> Result<Int> { bar("a") }

fn bar(s: String) -> Result<Int> {
  return Err(Error::Foo("boom"));
  Ok(4)
}

fn baz() -> Result<Int> {
  let _ = foo(false)?;

  unreachable!();
  Ok(1)
}

fn borgo_main() {
  baz().assert_eq(Err(Error::Foo("boom")));
}

OUTPUT:

---
package main

import borgo "borgo/runtime"

var _ = borgo.Unit

func make_Error_Foo(arg_0 any) any {
	return Error_Foo{arg_0}
}

type Error_Foo struct {
	Field0 any
}
type Error any

func foo(b any) any {

	{

		return bar("a")
	}
}
func bar(s any) any {

	{

		return make_Result_Err(make_Error_Foo("boom"))

		return make_Result_Ok(4)
	}
}
func baz() any {

	{
		var var1 any
		_ = var1

		var2_check := foo(false)

		if ret, ok := var2_check.(Result_Ok); ok {
			// $ret = ret.Field0
			var1 = ret.Field0
		} else {
			return var2_check
		}

		_ = var1
		Debug_unreachable()

		return make_Result_Ok(1)
	}
}
func borgo_main() any {

	{

		return Debug_assert_eq(baz(), make_Result_Err(make_Error_Foo("boom")))
	}
}
func Error_equals(values ...any) any {
	return borgo.OverloadImpl("equals", values)
}
func Error_to_hash(values ...any) any {
	return borgo.OverloadImpl("to_hash", values)
}
func Error_to_string(values ...any) any {
	return borgo.OverloadImpl("to_string", values)
}
func pkg_user_init() {
	borgo.RegisterTypeConstructor("Error::Foo", "Error_Foo")
	borgo.RegisterMakeFunction("Error::Foo", make_Error_Foo)
	borgo.RegisterGlobalFunction("foo", foo)
	borgo.RegisterGlobalFunction("bar", bar)
	borgo.RegisterGlobalFunction("baz", baz)
	borgo.RegisterGlobalFunction("borgo_main", borgo_main)
}
