use time;

fn FileInfoToDirEntry(info: FileInfo) -> DirEntry {
    EXT
}

fn ReadDir(fsys: FS, name: string) -> Result<[DirEntry]> {
    EXT
}

fn Sub(fsys: FS, dir: string) -> Result<FS> {
    EXT
}

fn Stat(fsys: FS, name: string) -> Result<FileInfo> {
    EXT
}

fn Glob(fsys: FS, pattern: string) -> Result<[string]> {
    EXT
}

fn ReadFile(fsys: FS, name: string) -> Result<[byte]> {
    EXT
}

fn ValidPath(name: string) -> bool {
    EXT
}

fn WalkDir(fsys: FS, root: string, fn_: WalkDirFunc) -> error {
    EXT
}

impl PathError {
    fn Error(&self) -> string {
        EXT
    }

    fn Timeout(&self) -> bool {
        EXT
    }

    fn Unwrap(&self) -> error {
        EXT
    }
}

impl FileMode {
    fn IsDir(self) -> bool {
        EXT
    }

    fn IsRegular(self) -> bool {
        EXT
    }

    fn Perm(self) -> FileMode {
        EXT
    }

    fn String(self) -> string {
        EXT
    }

    fn Type(self) -> FileMode {
        EXT
    }
}

type WalkDirFunc = fn(path: string, d: DirEntry, err: error) -> error;

struct FileMode(uint32);

trait DirEntry {
    fn Name() -> string;
    fn IsDir() -> bool;
    fn Type() -> FileMode;
    fn Info() -> Result<FileInfo>;
}

trait FS {
    fn Open(name: string) -> Result<File>;
}

trait File {
    fn Stat() -> Result<FileInfo>;
    fn Read(param0: [byte]) -> Result<int>;
    fn Close() -> error;
}

trait FileInfo {
    fn Name() -> string;
    fn Size() -> int64;
    fn Mode() -> FileMode;
    fn ModTime() -> time::Time;
    fn IsDir() -> bool;
    fn Sys() -> any;
}

trait GlobFS: FS {
    fn Glob(pattern: string) -> Result<[string]>;
}

struct PathError {
    Op: string,
    Path: string,
    Err: error,
}

trait ReadDirFS: FS {
    fn ReadDir(name: string) -> Result<[DirEntry]>;
}

trait ReadDirFile: File {
    fn ReadDir(n: int) -> Result<[DirEntry]>;
}

trait ReadFileFS: FS {
    fn ReadFile(name: string) -> Result<[byte]>;
}

trait StatFS: FS {
    fn Stat(name: string) -> Result<FileInfo>;
}

trait SubFS: FS {
    fn Sub(dir: string) -> Result<FS>;
}
