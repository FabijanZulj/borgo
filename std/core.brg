use fmt;
use reflect;

type Map<K, V> = ();

type EnumerateSlice<T> = ();

type VarArgs<T> = ();

type Channel<T> = ();
type Sender<T> = ();
type Receiver<T> = ();

enum Result<T, E> {
    Ok(T),
    Err(E),
}

impl<T, E> Result<T, E> {
    fn IsOk(self) -> bool {
        match self {
            Ok(_) => true,
            Err(_) => false,
        }
    }

    fn unwrap(self) -> T {
        rawgo!(
            "
      if self.tag == Result_Err {
        inspect(self.Err)
        panic(\"Unwrapped Err value\")
      }

      return self.Ok
    "
        )
    }
}

enum Option<T> {
    Some(T),
    None,
}

impl<T> Option<T> {
    fn IsSome(self) -> bool {
        match self {
            Some(_) => true,
            None => false,
        }
    }

    fn IsNone(self) -> bool {
        !self.IsSome()
    }

    fn unwrap_or(self, def: T) -> T {
        match self {
            Some(x) => x,
            None => def,
        }
    }

    fn unwrap_or_else(self, f: fn() -> T) -> T {
        match self {
            Some(x) => x,
            None => f(),
        }
    }

    fn unwrap(self) -> T {
        rawgo!(
            "
        if self.tag == Option_None {
          panic(\"Unwrapped None value\")
        }

        return self.Some
      "
        )
    }

    fn ToOption<T>(value: T, check: bool) -> Option<T> {
        if check {
            Some(value)
        } else {
            None
        }
    }
}

struct Tuple2<T, Y> {
    first: T,
    second: Y,
}

struct Tuple3<T, Y, Z> {
    first: T,
    second: Y,
    third: Z,
}

fn zero_value<T>() -> T {
    rawgo!(
        "
    var m T
    return m
  "
    )
}

fn assert_eq<T>(a: T, b: T) {
    if !reflect.DeepEqual(a, b) {
        inspect(a);
        inspect(b);
        rawgo!("panic(\"something wrong\")")
    }
}

fn inspect<T>(a: T) -> T {
    fmt.Printf("%+v\n", a);
    a
}

fn Debug_unreachable<T>() -> T {
    rawgo!("panic(\"unreachable code\")")
}

fn to_result(e: error) -> Result<()> {
    rawgo!(
        "if e != nil {
    return struct{}{}, e
  }
  return struct{}{}, nil
  "
    )
}

impl<T> [T] {
    fn len(self) -> int {
        rawgo!("return len(self)")
    }

    fn enumerate(self) -> EnumerateSlice<T> {
        rawgo!("return self")
    }

    fn set(&mut self, index: int, item: T) {
        rawgo!("self[index] = item")
    }

    fn append(&mut self, item: T) -> [T] {
        rawgo!("return append(self, item)")
    }

    fn get(self, i: int) -> Option<T> {
        rawgo!(
            "
            if i < 0 || i >= len(self) {
              return *new(T), false
            }

      return self[i], true
    "
        )
    }
}

impl<K: comparable, V> Map<K, V> {
    fn new() -> Map<K, V> {
        rawgo!("return map[K]V{}")
    }

    fn len(self) -> int {
        rawgo!("return len(self)")
    }

    fn insert(self, k: K, v: V) {
        rawgo!("self[k] = v")
    }

    fn get(self, k: K) -> Option<V> {
        rawgo!(
            "
        v, ok := self[k]
        return v, ok
        "
        )
    }
}

impl<T> Channel<T> {
    fn new() -> (Sender<T>, Receiver<T>) {
        rawgo!(
            "
    ch := make(chan T)
    return Tuple2[chan<- T, <-chan T]{ first: ch, second: ch }
    "
        )
    }
}

impl<T> Sender<T> {
    fn send(&mut self, value: T) {
        rawgo!("self <- value")
    }

    fn close(&mut self) {
        rawgo!("close(self)")
    }
}

impl<T> Receiver<T> {
    fn recv(&self) -> T {
        rawgo!("return <- self")
    }
}

impl string {
    fn enumerate(self) -> EnumerateSlice<rune> {
        rawgo!("return []rune(self)")
    }
}

#[package(path = __global, name = __global)]
mod global {
    trait ComplexType {}
    trait FloatType {}
    trait IntegerType {}
    trait any {}
    type bool = ();
    type byte = ();
    trait comparable {}
    type complex128 = ();
    type complex64 = ();
    trait error {
        fn Error() -> string;
    }
    type float32 = ();
    type float64 = ();
    type int = ();
    type int16 = ();
    type int32 = ();
    type int64 = ();
    type int8 = ();
    type rune = ();
    type string = ();
    type uint = ();
    type uint16 = ();
    type uint32 = ();
    type uint64 = ();
    type uint8 = ();
    type uintptr = ();

    fn string(a: any) -> string {
        EXT
    }
}

#[package(path = errors, name = errors)]
mod errors {
    fn New(text: string) -> error {
        EXT
    }
}

#[package(path = fmt, name = fmt)]
mod fmt {
    use io;

    fn Printf(format: string, a: VarArgs<any>) -> Result<int> {
        EXT
    }
    fn Fprintf(w: io::Writer, format: string, a: VarArgs<any>) -> Result<int> {
        EXT
    }
    fn Errorf(format: string, a: VarArgs<any>) -> error {
        EXT
    }
    fn Println(a: VarArgs<any>) {
        EXT
    }
}

#[package(path = io/fs, name = io::fs)]
mod fs {
    struct FileMode {}

    trait FileInfo {
        fn Name() -> string;
        fn Size() -> int64;
        fn Mode() -> FileMode;
        // fn ModTime() -> time.Time;
        fn IsDir() -> bool;
        fn Sys() -> any;
    }

    impl FileMode {
        fn IsRegular(&self) -> bool {
            EXT
        }
    }
}

#[package(path = net/http, name = net::http)]
mod http {
    struct Request {}

    trait ResponseWriter {
        fn Write(bytes: [byte]) -> Result<int>;
    }

    trait Handler {
        fn ServeHTTP(w: ResponseWriter, r: &Request);
    }

    fn Handle(pattern: string, handler: Handler) {
        EXT
    }
    fn ListenAndServe(addr: string, handler: Handler) {
        EXT
    }
}

#[package(path = io, name = io)]
mod io {
    trait Writer {
        fn Write(bytes: [byte]) -> Result<int>;
    }
    trait Reader {
        fn Read(p: [byte]) -> Result<int>;
    }

    trait ReadWriter: Reader + Writer {}

    fn Copy(dst: &mut Writer, src: &Reader) -> Result<int64> {
        EXT
    }
}

#[package(path = log, name = log)]
mod log {
    fn Fatalf(format: string, a: VarArgs<any>) {
        EXT
    }
}

#[package(path = math, name = math)]
mod math {
    const Pi: float64 = 0;
}

#[package(path = os, name = os)]
mod os {
    use io::fs;

    type FileInfo = fs::FileInfo;

    struct File {}


    impl File {
        fn Close(&mut self) -> error {
            EXT
        }
        fn Write(&mut self, b: [byte]) -> Result<int> {
            EXT
        }
        fn Read(&self, b: [byte]) -> Result<int> {
            EXT
        }
    }

    fn Create(name: string) -> Result<&mut File> {
        EXT
    }
    fn LookupEnv(key: string) -> Option<string> {
        EXT
    }
    fn Open(name: string) -> Result<&mut File> {
        EXT
    }
    fn ReadFile(path: string) -> Result<[byte]> {
        EXT
    }
    fn Stat(name: string) -> Result<FileInfo> {
        EXT
    }
}

#[package(path = math/rand, name = math::rand)]
mod rand {
    fn Int() -> int {
        EXT
    }
    fn Float64() -> float64 {
        EXT
    }
}

#[package(path = reflect, name = reflect)]
mod reflect {
    fn DeepEqual<T, Y>(a: T, b: Y) -> bool {
        EXT
    }
}

#[package(path = strings, name = strings)]
mod strings {
    fn HasPrefix(s: string, prefix: string) -> bool {
        EXT
    }
}

#[package(path = sync, name = sync)]
mod sync {
    struct Mutex {}
    struct WaitGroup {}

    impl Mutex {
        fn Lock(&mut self) {
            EXT
        }

        fn Unlock(&mut self) {
            EXT
        }
    }

    impl WaitGroup {
        fn Add(&mut self, delta: int) {
            EXT
        }
        fn Done(&mut self) {
            EXT
        }
        fn Wait(&mut self) {
            EXT
        }
    }
}
